package extends1.ex;

public class Book extends Item {

    private String author;
    private String isbn;

    public Book(String name, int price, String author, String isbn) {
        super(name, price);
        this.author = author;
        this.isbn = isbn;
    }


    /**
     공부하다가, 내가 찾아본 내용을 좀 더 자세하게 코드와 서술한다.

     extends1.ex의 Item(최상위 부모클래스)와 자식 부모클래스의 @Override 어노테이션에 관한 내용이다.

     @Override
     애너테이션은 자식 클래스에서 부모 클래스의 메소드를 재정의(override)할 때 사용됩니다. 이 경우, Album 클래스가 Item 클래스로부터 상속받은 print() 메소드를 재정의하여, 앨범에 대한 추가 정보를 출력하기 위해 사용합니다.

     이유
     1. 기능 확장
     1.1) 부모 클래스의 print() 메소드는 기본적인 정보(이름과 가격)를 출력합니다.
     1.2) 자식 클래스인 Album에서 print() 메소드를 재정의함으로써, 앨범에 특화된 정보를(예: 아티스트) 추가로 출력할 수 있습니다.

     2. 다형성
     2.1) 재정의된 메소드를 통해 각 클래스에서 고유한 동작을 구현할 수 있습니다.
     2.2) 2.1의 예시로. 다른 자식 클래스가 있다면 그 클래스에 맞게 print() 메소드를 또 다르게 재정의할 수 있습니다.

     3. 코드의 명확성
     3.1) @Override 애너테이션을 사용하면 컴파일러가 부모 클래스의 메소드를 제대로 재정의했는지 확인해줍니다.
     3.2) 만약 부모 클래스에 해당 메소드가 없거나 시그니처가 다르면 컴파일 에러가 발생합니다. 이는 코드의 오류를 줄이는 데 도움이 됩니다.

     >> 결론적으로, @Override는 메소드 재정의의 의도를 명확히 하고, 코드의 안전성을 높여주는 역할을 합니다.


     @Override 애너테이션을 사용하지 않고도 메소드를 정의할 수 있지만, 몇 가지 이유로 사용하는 것이 좋습니다.

     1. 명확성:
     1.1) @Override를 사용하면 이 메소드가 부모 클래스의 메소드를 재정의하고 있다는 것을 명확하게 나타냅니다.
     1.2) 코드의 가독성을 높이고, 다른 개발자가 코드를 읽을 때 이해하기 쉽게 만듭니다.

     2. 컴파일러 검증:
     2.1) @Override를 사용하면 컴파일러가 이 메소드가 실제로 부모 클래스의 메소드를 재정의하는지 확인합니다.
     2.2) 만약 부모 클래스에 해당 메소드가 없거나 시그니처가 다르면 컴파일 에러가 발생합니다. 이를 통해 실수를 줄일 수 있습니다.

     3. 유지보수
     3.1) 나중에 코드를 수정할 때, @Override가 있으면 해당 메소드가 부모 클래스의 메소드를 재정의하고 있다는 것을 쉽게 알 수 있어 유지보수가 용이합니다.

      * */

    @Override
    public void print() {
        super.print();
        System.out.println("- 저자: " + this.author + ", isbn: " + this.isbn);
    }


}
