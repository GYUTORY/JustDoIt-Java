


## Overload아 Override의 차이

### 오버라이드 (Override)





#### 정의
- 서브클래스가 슈퍼클래스의 메서드를 재정의하는 것입니다.
- 즉, 서브클래스에서 슈퍼클래스의 메서드와 동일한 이름, 반환 타입, 매개변수를 가진 메서드를 구현하는 것입니다.

#### 목적
- 상속받은 메서드의 동작을 변경하거나 확장하기 위해 사용됩니다.


### 예시
```java


class Animal {
    void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
    System.out.println("Dog barks");
    }
}
```

---

## 메서드 오버라이딩 조건
- **메서드 이름**
    - 메서드 이름이 같아야 한다.



- **메서드 매개변수(파라미터)**
    - 매개변수(파라미터) 타입, 순서, 개수가 같아야 한다.



- **반환 타입**
    - **반환 타입이 같아야 한다**. 단 반환 타입이 하위 클래스 타입일 수 있다.



- **접근 제어자**
    - 오버라이딩 메서드의 접근 제어자는 상위 클래스의 메서드보다 더 제한적이어서는 안된다. 예를 들 어, 상위 클래스의 메서드가 `protected` 로 선언되어 있으면 하위 클래스에서 이를 `public` 또는
      `protected` 로 오버라이드할 수 있지만, `private` 또는 `default` 로 오버라이드 할 수 없다.



- **예외**: 오버라이딩 메서드는 상위 클래스의 메서드보다 더 많은 체크 예외를 `throws` 로 선언할 수 없다. 하지만 더 적거나 같은 수의 예외, 또는 하위 타입의 예외는 선언할 수 있다. 
  `static` , `final` , `private` : 키워드가 붙은 메서드는 오버라이딩 될 수 없다.
    - `static` : 클래스 레벨에서 작동하므로 인스턴스 레벨에서 사용하는 오버라이딩이 의미가 없다. 쉽게 이 야기해서 그냥 클래스 이름을 통해 필요한 곳에 직접 접근하면 된다.
    - `final` : 재정의를 금지한다.
    - `private` : 해당 클래스에서만 접근 가능하기 때문에 하위 클래스에서 보이지 않는다. 따라서 오 버라이딩 할 수 없다.

- **생성자 오버라이딩**
    - 생성자는 오버라이딩 할 수 없다.


---
### 참고

### 접근제어자의 종류
1. private : 모든 외부 호출을 막는다.
2. default(package-private) : 같은 패키지안에서 호출은 허용한다.
3. protected : 같은 패키지안에서 허용한다. 패키지가 달라도 상속 관계의 호출은 허용한다.
4. public : 모든 외부 호출을 허용한다.

---

### 오버로드 (Overload)

### 정의
 - 같은 이름의 메서드를 여러 개 정의하되, 매개변수의 타입이나 개수, 순서가 다른 경우입니다. 반환 타입은 다를 수 있지만, 매개변수가 다르게 정의되어야 합니다.

### 목적
 - 같은 기능을 수행하지만, 입력값의 형태에 따라 다르게 처리할 수 있도록 하기 위해 사용됩니다.

예시
```java
class MathUtils {
    int add(int a, int b) {
        return a + b;
    }

    double add(double a, double b) {
        return a + b;
    }

    int add(int a, int b, int c) {
        return a + b + c;
    }
}
```

#### 요약
- 오버라이드: 상속 관계에서 메서드를 재정의하는 것.
- 오버로드: 같은 이름의 메서드를 매개변수의 차이로 여러 개 정의하는 것.
> 이 두 개념은 Java의 다형성을 활용하는 데 중요한 역할을 합니다.
